---
layout: post
title: 正则表达式
date: 2019-10-30 10:00:00 +0800
categories: 【编程常识】
tag: 【工具】
---

> [参考文档1](https://www.runoob.com/regexp/regexp-intro.html)
> 


### 本文解决四个问题
1. 正则表达式能够干什么?
2. 正则表达式怎么用?
3. 有哪些常用的正则实际例子?
4. 正则在Python、Swift、Kotlin中的使用方法?


### 正则表达式能够干什么?
1. 数据验证
- 字符串是否具有固定的格式
- 例如: 身份证号、手机号、邮箱、信用卡、BTC地址等

2. 文本替换
- 识别出字符串内的特定文本, 删除或替换这些文本.
- 例如: 将html中的标签全部去除 

3. 提取子字符串
- 识别出符合特定文本, 并提取出来
- 获取网页中的所有URL、手机号、邮箱


### 正则表达式怎么用?

- 字符类型
	- 普通字符
		- 非打印字符
	- 特殊字符
		- 特殊
			- () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
			- . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
			- [ 标记一个中括号表达式的开始。要匹配 [，请使用 \[。
			- \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。
			- \|	指明两项之间的一个选择。要匹配 \|，请使用 \ \|。
		- 限定符
			- 含义: 指定正则表达式的一个给定组件必须要出现多少次才能满足匹配
			- `*` 匹配前面的子表达式零次或多次。
			- `+` 匹配前面的子表达式一次或多次。
			- `?` 匹配前面的子表达式零次或一次。
			- `{n}` n是一个非负整数。匹配确定的 n 次。
			- `{n,}` n是一个非负整数。至少匹配n 次。
			- `{n,m}` m和n均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。
			- ⚠️ `*、+` 限定符都是贪婪的, 在它们的后面加上一个?就可以实现非贪婪或最小匹配。
		- 定位符
			- 含义: 定位符使您能够将正则表达式固定到行首或行尾。
			- ^ 匹配输入字符串开始的位置。
			- $ 匹配输入字符串结尾的位置。
			- \b 匹配一个单词边界，即字与空格间的位置。
			- \B 非单词边界匹配。
- 运算符优先级
	- \	转义符
	- (), (?:), (?=), []			圆括号和方括号
	- *, +, ?, {n}, {n,}, {n,m}	  	限定符
	- ^, $, \\任何元字符、任何字符    	定位点和序列
	- \|								替换，"或"操作
- 规则
	- 基本模式匹配
		- ^ $ 
	- 字符簇
		- [[:alpha:]]	任何字母
		- [[:digit:]]	任何数字
		- [[:alnum:]]	任何字母和数字
		- [[:space:]]	任何空白字符
		- [[:upper:]]	任何大写字母
		- [[:lower:]]	任何小写字母
		- [[:punct:]]	任何标点符号
		- [[:xdigit:]]	任何16进制的数字，相当于[0-9a-fA-F]
	- 确定重复出现
		- 特殊字符 * 与 {0,} 是相等的，它们都代表着 0 个或多个前面的内容 。
		- 所有包含一个以上的字母、数字或下划线的字符串 
			- `^[a-zA-Z0-9_]{1,}$`      	
		- 所有的正整数 
			- `^[1-9][0-9]{0,}$`       
		- 所有的整数
			- `^\-{0,1}[0-9]{1,}$`       
		- 所有的浮点数
			- `^[-]?[0-9]+\.?[0-9]+$` 


### 3. 有哪些常用的正则实际例子?
- 匹配双字节汉字: 
	- `[^u4e00-u9fa5]`
- 匹配中文字符
	- `[u4e00-u9fa5]`
- 匹配HTML标记:
	- `<(S*?)[^>]*>.*?|<.*? />`
- 匹配HTML标签: 
	- `</?[a-zA-Z]+[^><]*>`
- 匹配空白行:   
	-  `ns*r`
- 匹配首尾空白字符
	-  `^s*|s*$`
- 匹配Email地址
	- `w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*`
- 匹配网址URL的正则表达式：
	- `http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?`
- 匹配国内电话号码：
	- `[0-9]{3}-[0-9]{8}|[0-9]{4}-[0-9]{7}`
- 匹配ip地址：
	- `[1-2]?[0-9]{1,2}.[1-2]?[0-9]{1,2}.[1-2]?[0-9]{1,2}.[1-2]?[0-9]{1,2}`
- 匹配26个英文字母字符串
	- ^[A-Za-z]+$　
- 验证一年的12个月
	- `^(0?[1-9]|1[0-2])$`
- 验证一个月的31天：
	- `^((0?[1-9])|((1|2)[0-9])|30|31)$`

### 4. Python、Swift、Kotlin中的使用

- Python:
	> import re 
	> 
	> re.match( r'</?[a-zA-Z]+[^><]*>', line, re.M \| re.I)
	> 
	> re.findall("</?[a-zA-Z]+[^><]*>", "123444-1222")
	> 
	>  re.compile("</?[a-zA-Z]+[^><]*>").sub('replace string', "origin string")


- Kotlin:
	> Regex("</?[a-zA-Z]+[^><]*>").matches("string")
	> 
	> Regex("</?[a-zA-Z]+[^><]*>").findAll("<p></p>")
	> 
	> Regex("</?[a-zA-Z]+[^><]*>").replace("new string", "replace string")


- Swift:
	> var string = "origin string"
	> 
	> let pattern = "</?[a-zA-Z]+[^><]*>"
	> 
	> let regex = try? NSRegularExpression(pattern: pattern, options: [])
	>
	> if let results = regex?.matches(in: acount, options: [], range: NSRange(location: 0, length: acount.count)), results.count != 0 {
	> 
    > &emsp;&emsp;for result in results{
    > 
    > &emsp;&emsp;&emsp;&emsp; let string = (acount as NSString).substring(with: result.range)
    >
    > &emsp;&emsp; }
    > 
	> }


> 正则不难很有用, 能积累点最好. 









